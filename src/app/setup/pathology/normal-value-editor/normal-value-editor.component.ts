import { Component, Input, Output, EventEmitter, OnInit, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, FormArray, Validators, ReactiveFormsModule } from '@angular/forms';
import { SuccessAlertComponent } from '../../../shared/components/success-alert/success-alert.component';

export interface NormalValue {
  _id?: string;
  type: 'Numeric range' | 'Text';
  gender?: string; // Changed from sex to gender
  minAge?: string; // Changed to string to store "14 Years" format
  maxAge?: string; // Changed to string to store "100 Years" format
  lowerValue?: string;
  upperValue?: string;
  textValue?: string;
  displayInReport?: string;
  remark?: string;
}

export interface TestParameterDefinition {
  order: number;
  name: string;
  unit?: string;
  inputType: 'Numeric' | 'Single Line' | 'Paragraph';
  defaultResult?: string;
  isOptional: boolean;
  groupBy?: string;
  normalValues?: NormalValue[];
}

@Component({
  selector: 'app-normal-value-editor',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, SuccessAlertComponent],
  templateUrl: './normal-value-editor.component.html',
  styleUrls: ['./normal-value-editor.component.css']
})
export class NormalValueEditorComponent implements OnInit {
  @Input() parameter: TestParameterDefinition | null = null;
  @Input() normalValues: NormalValue[] = [];
  @Output() save = new EventEmitter<NormalValue[]>();
  @Output() cancel = new EventEmitter<void>();
  @Output() close = new EventEmitter<void>();

  normalValueForm: FormGroup;
  selectedType: 'Numeric range' | 'Text' = 'Numeric range';
  manualEditModes: boolean[] = []; // Track which rows are in manual edit mode

  // Success alert properties
  showAlert = false;
  alertMessage = '';

  // Store previous state for each type
  previousNumericRanges: any[] = [];
  previousTextRanges: any[] = [];

  genderOptions = [
    { value: 'Any', label: 'Any' },
    { value: 'Male', label: 'Male' },
    { value: 'Female', label: 'Female' },
    { value: 'Other', label: 'Other' }
  ];

  ageUnits = [
    { value: 'Years', label: 'Years' },
    { value: 'Months', label: 'Months' },
    { value: 'Days', label: 'Days' }
  ];

  constructor(
    private fb: FormBuilder,
    private cdr: ChangeDetectorRef
  ) {
    this.normalValueForm = this.fb.group({
      type: ['Numeric range', Validators.required],
      normalValueRanges: this.fb.array([])
    });
  }

  ngOnInit(): void {
    console.log('ðŸ”„ Normal Value Editor - ngOnInit');
    console.log('ðŸ“¥ Received normalValues:', this.normalValues);
    console.log('ðŸ“¥ Received parameter:', this.parameter);
    this.initializeForm();
  }

  initializeForm(): void {
    const normalValueRanges = this.normalValueForm.get('normalValueRanges') as FormArray;

    console.log('ðŸ”§ Initializing form with normalValues:', this.normalValues);

    if (this.normalValues && this.normalValues.length > 0) {
      console.log('âœ… Loading existing normal values:', this.normalValues.length);

      // Set the type based on the first normal value
      if (this.normalValues[0]?.type) {
        this.selectedType = this.normalValues[0].type;
        this.normalValueForm.patchValue({ type: this.selectedType });
      }

      this.normalValues.forEach((value, index) => {
        console.log(`ðŸ“‹ Loading normal value ${index + 1}:`, value);
        const formGroup = this.createNormalValueGroup(value);
        normalValueRanges.push(formGroup);

        // Set manual edit mode if displayInReport exists and is different from auto-generated
        const hasCustomDisplay = !!value.displayInReport && value.displayInReport.trim() !== '';
        let isManualMode = false;

        if (hasCustomDisplay) {
          // Check if the displayInReport is different from what would be auto-generated
          const autoGenerated = value.lowerValue && value.upperValue ? `${value.lowerValue} - ${value.upperValue}` : '';
          isManualMode = value.displayInReport !== autoGenerated && value.displayInReport !== `${value.lowerValue}-${value.upperValue}`;
        }

        this.manualEditModes.push(isManualMode);
      });
    } else {
      console.log('âž• No existing normal values, creating default row');
      // Always start with 1 row when opening from "Edit normal values"
      normalValueRanges.push(this.createNormalValueGroup());
      this.manualEditModes.push(false); // Initialize manual edit mode
    }

    console.log('ðŸ Form initialized with', normalValueRanges.length, 'ranges');
  }

  createNormalValueGroup(value?: NormalValue): FormGroup {
    console.log('ðŸ”§ Creating form group for value:', value);

    // Parse age values if they are in "14 Years" format
    let minAgeValue = '';
    let maxAgeValue = '';
    let minAgeUnit = 'Years';
    let maxAgeUnit = 'Years';

    if (value?.minAge !== undefined && value?.minAge !== null && typeof value.minAge === 'string') {
      const minAgeParts = value.minAge.trim().split(/\s+/);
      if (minAgeParts.length >= 2) {
        minAgeValue = minAgeParts[0];
        minAgeUnit = minAgeParts[1];
      } else {
        minAgeValue = value.minAge;
      }
    }

    if (value?.maxAge !== undefined && value?.maxAge !== null && typeof value.maxAge === 'string') {
      const maxAgeParts = value.maxAge.trim().split(/\s+/);
      if (maxAgeParts.length >= 2) {
        maxAgeValue = maxAgeParts[0];
        maxAgeUnit = maxAgeParts[1];
      } else {
        maxAgeValue = value.maxAge;
      }
    }

    const group = this.fb.group({
      _id: [value?._id || ''],
      type: [value?.type || this.selectedType],
      gender: [value?.gender || 'Any'], // Changed from sex to gender
      minAge: [minAgeValue || '0'],
      maxAge: [maxAgeValue || '150'],
      minAgeUnit: [minAgeUnit],
      maxAgeUnit: [maxAgeUnit],
      lowerValue: [value?.lowerValue || ''],
      upperValue: [value?.upperValue || ''],
      textValue: [value?.textValue || ''],
      displayInReport: [value?.displayInReport || ''],
      remark: [value?.remark || ''],
      editMode: [false] // For toggle edit functionality
    });

    console.log('âœ… Created form group:', group.value);

    // Add conditional validation based on type
    if (this.selectedType === 'Text') {
      group.get('textValue')?.setValidators([Validators.required]);
    }

    // Add listeners for auto-updating display in report
    const currentIndex = this.normalValueRanges.length;

    // Listen to lowerValue changes
    group.get('lowerValue')?.valueChanges.subscribe(() => {
      if (!this.isManualEditMode(currentIndex)) {
        // Trigger change detection for auto-generated display
        this.cdr.detectChanges();
      }
    });

    // Listen to upperValue changes
    group.get('upperValue')?.valueChanges.subscribe(() => {
      if (!this.isManualEditMode(currentIndex)) {
        // Trigger change detection for auto-generated display
        this.cdr.detectChanges();
      }
    });

    return group;
  }

  get normalValueRanges(): FormArray {
    return this.normalValueForm.get('normalValueRanges') as FormArray;
  }

  onTypeChangeEvent(event: Event): void {
    const target = event.target as HTMLSelectElement;
    const type = target.value as 'Numeric range' | 'Text';
    this.onTypeChange(type);
  }

  onTypeChange(type: 'Numeric range' | 'Text'): void {
    // Save current state before switching
    if (this.selectedType === 'Numeric range') {
      this.previousNumericRanges = this.normalValueRanges.value.map((range: any) => ({ ...range }));
    } else if (this.selectedType === 'Text') {
      this.previousTextRanges = this.normalValueRanges.value.map((range: any) => ({ ...range }));
    }

    this.selectedType = type;
    this.normalValueForm.patchValue({ type });

    // Clear existing ranges
    while (this.normalValueRanges.length !== 0) {
      this.normalValueRanges.removeAt(0);
    }
    this.manualEditModes = [];

    // Restore previous state or create default
    if (type === 'Text') {
      if (this.previousTextRanges.length > 0) {
        // Restore previous text ranges
        this.previousTextRanges.forEach(rangeData => {
          const textRange = this.createNormalValueGroup();
          textRange.patchValue({ ...rangeData, type: 'Text' });
          this.normalValueRanges.push(textRange);
          this.manualEditModes.push(false);
        });
      } else {
        // Create default single text range
        const textRange = this.createNormalValueGroup();
        textRange.patchValue({ type: 'Text' });
        this.normalValueRanges.push(textRange);
        this.manualEditModes.push(false);
      }
    } else {
      if (this.previousNumericRanges.length > 0) {
        // Restore previous numeric ranges
        this.previousNumericRanges.forEach(rangeData => {
          const numericRange = this.createNormalValueGroup();
          numericRange.patchValue({ ...rangeData, type: 'Numeric range' });
          this.normalValueRanges.push(numericRange);
          this.manualEditModes.push(false);
        });
      } else {
        // Create default 1 numeric range (user can add more using "Add more" button)
        const numericRange = this.createNormalValueGroup();
        numericRange.patchValue({ type: 'Numeric range' });
        this.normalValueRanges.push(numericRange);
        this.manualEditModes.push(false);
      }
    }

    this.cdr.detectChanges();
  }

  addMoreRange(): void {
    const newRange = this.createNormalValueGroup();
    newRange.patchValue({ type: this.selectedType });
    this.normalValueRanges.push(newRange);
    this.manualEditModes.push(false); // Initialize manual edit mode for new range

    // Update the stored state for current type
    if (this.selectedType === 'Numeric range') {
      this.previousNumericRanges = this.normalValueRanges.value.map((range: any) => ({ ...range }));
    }

    this.cdr.detectChanges();
  }

  removeRange(index: number): void {
    if (this.normalValueRanges.length > 1) {
      this.normalValueRanges.removeAt(index);
      this.manualEditModes.splice(index, 1);

      // Update the stored state for current type
      if (this.selectedType === 'Numeric range') {
        this.previousNumericRanges = this.normalValueRanges.value.map((range: any) => ({ ...range }));
      }

      this.cdr.detectChanges();
    }
  }

  toggleEditMode(index: number): void {
    const range = this.normalValueRanges.at(index);
    const currentEditMode = range.get('editMode')?.value;
    range.get('editMode')?.setValue(!currentEditMode);

    // If entering edit mode, populate with current display text
    if (!currentEditMode) {
      const currentDisplay = range.get('displayInReport')?.value;
      if (!currentDisplay) {
        const displayText = this.getDisplayText(range);
        range.get('displayInReport')?.setValue(displayText);
      }
    }
  }

  getDisplayText(range: any): string {
    const lowerValue = range.get('lowerValue')?.value;
    const upperValue = range.get('upperValue')?.value;
    const displayInReport = range.get('displayInReport')?.value;

    if (displayInReport) {
      return displayInReport;
    }

    if (lowerValue && upperValue) {
      return `${lowerValue} - ${upperValue}`;
    } else if (lowerValue) {
      return lowerValue;
    } else if (upperValue) {
      return upperValue;
    }

    return '-';
  }

  clearDisplayValue(index: number): void {
    const range = this.normalValueRanges.at(index);
    range.get('displayInReport')?.setValue('');
    range.get('editMode')?.setValue(false);
  }

  onSave(): void {
    console.log('ðŸ’¾ Saving normal values...');
    console.log('ðŸ“‹ Form valid:', this.normalValueForm.valid);
    console.log('ðŸ“‹ Form value:', this.normalValueForm.value);

    if (this.normalValueForm.valid) {
      const formValue = this.normalValueForm.value;
      const normalValues: NormalValue[] = formValue.normalValueRanges.map((range: any, index: number) => {
        console.log(`ðŸ“ Processing range ${index + 1}:`, range);

        const normalValue = {
          _id: range._id || undefined,
          type: range.type,
          gender: range.gender, // Changed from range.sex to range.gender
          minAge: (range.minAge !== null && range.minAge !== undefined && range.minAge !== '') ? `${range.minAge} ${range.minAgeUnit || 'Years'}` : undefined,
          maxAge: (range.maxAge !== null && range.maxAge !== undefined && range.maxAge !== '') ? `${range.maxAge} ${range.maxAgeUnit || 'Years'}` : undefined,
          lowerValue: range.type === 'Numeric range' ? range.lowerValue : undefined,
          upperValue: range.type === 'Numeric range' ? range.upperValue : undefined,
          textValue: range.type === 'Text' ? range.textValue : undefined,
          displayInReport: range.displayInReport || (range.type === 'Numeric range' && range.lowerValue && range.upperValue ? `${range.lowerValue}-${range.upperValue}` : ''),
          remark: range.remark || ''
        };

        console.log(`âœ… Created normal value ${index + 1}:`, normalValue);
        return normalValue;
      });

      console.log('ðŸŽ¯ Final normal values array:', normalValues);

      // Show success alert
      this.alertMessage = `Normal values updated successfully for parameter "${this.parameter?.name || 'Parameter'}"`;
      this.showAlert = true;

      // Hide alert after 2 seconds, emit save event, and close modal
      setTimeout(() => {
        this.showAlert = false;
        console.log('ðŸ“¤ Emitting save event with:', normalValues);
        this.save.emit(normalValues);
        this.close.emit(); // Close the modal
      }, 2000);
    } else {
      console.log('âŒ Form is invalid:', this.normalValueForm.errors);
      // Mark all fields as touched to show validation errors
      this.normalValueForm.markAllAsTouched();
    }
  }

  onCancel(): void {
    this.cancel.emit();
  }

  isNumericRange(): boolean {
    return this.selectedType === 'Numeric range';
  }

  isTextType(): boolean {
    return this.selectedType === 'Text';
  }

  onClose(): void {
    this.cancel.emit();
  }

  getAutoGeneratedRange(index: number): string {
    const range = this.normalValueRanges.at(index);
    if (range) {
      const lowerValue = range.get('lowerValue')?.value;
      const upperValue = range.get('upperValue')?.value;

      // Auto-generate based on what values are present
      if (lowerValue && upperValue) {
        // Both values: "23 - 54"
        return `${lowerValue} - ${upperValue}`;
      } else if (lowerValue && !upperValue) {
        // Only lower value: "23 -"
        return `${lowerValue} -`;
      } else if (!lowerValue && upperValue) {
        // Only upper value: "- 54"
        return `- ${upperValue}`;
      } else {
        // No values: "-"
        return '-';
      }
    }
    return '-';
  }

  enableManualEdit(index: number): void {
    // Set manual edit mode for this row
    this.manualEditModes[index] = true;
    const range = this.normalValueRanges.at(index);
    if (range) {
      // Clear the displayInReport field to start with empty textarea
      range.get('displayInReport')?.setValue('');
    }
  }

  cancelManualEdit(index: number): void {
    // Exit manual edit mode and return to auto-generated display
    this.manualEditModes[index] = false;
    const range = this.normalValueRanges.at(index);
    if (range) {
      // Clear any manual input to show auto-generated value
      range.get('displayInReport')?.setValue('');
    }
  }

  clearDisplayInReport(index: number): void {
    const range = this.normalValueRanges.at(index);
    if (range) {
      range.get('displayInReport')?.setValue('');
      // Switch back to auto-generated mode
      this.manualEditModes[index] = false;
    }
  }

  isManualEditMode(index: number): boolean {
    return this.manualEditModes[index] || false;
  }

  deleteRange(index: number): void {
    if (this.normalValueRanges.length > 1) {
      this.normalValueRanges.removeAt(index);
      this.manualEditModes.splice(index, 1);
    }
  }
}
